<html>
<head>

<script src="three.min.js"></script>
<script src="lobserCollection.js"></script>

</head>
<body>
<!-- ======= BUTTONS ======= -->


'r'-rotates, 's'-scales

<script>
	var renderer,scene,camera,geometry,material,width,height,tubemesh,count,sverts,camParent,plane,rotateParent,stx,sty,hirezGeo,hirezGeoSwitcher,scaleGeo,geoSX,geoSY,geoSZ,x,y,z,fun,funCount,ana,radius,funx,funy,funz,wScale,time,game,pPos,noise,noisy,reGeo,reGeoParent,metaDataString,instruct;
	var draw = false;
	var rotator = false;
	var mousePos;
	var tubes = [];
	sverts = "";
	var savingmode = false;

	window.onload=function(){

		init();
		animate();
	};

	function toggleSave(){
		savingmode = false;
		console.log("savingmode: " + savingmode);
	}

	function kill(){

		var obj, i;
		for ( i = scene.children.length - 1; i >= 0 ; i -- ) {
		    obj = scene.children[ i ];
		    if ( obj !== camera && obj!=light) {
		        scene.remove(obj);
		    }
		}
	}

	function init(){

		ana=false;	
		count=0;
		z=0.1;
		stx = [];
		sty = [];
		fun=false;
		game=false;
		noisy=false;
		funCount=0;
		wScale = 1;
		reGeo = true;

		funx = funy = funz = time = 0.0;
		funsc = 1;

		pPos = new THREE.Vector3();
		noise = new SimplexNoise();


		hirezGeo = true;
		hirezGeoSwitcher = true;
		scaleGeo = false;
		geoSX = geoSY = geoSZ = 1;

		renderer = new THREE.WebGLRenderer();
		renderer.setSize(window.innerWidth, window.innerHeight);
		document.body.appendChild(renderer.domElement);

		scene = new THREE.Scene();

		var mesher = new THREE.Mesh( new THREE.SphereGeometry( 12, 12, 12 ), new THREE.MeshLambertMaterial( { color:0x99DDFF } ) );

		//scene.add(mesher);

		var directionalLight = new THREE.DirectionalLight( 0xBBDDFF, .51 );
		directionalLight.position.set( 0, -1, -.1 );
		scene.add( directionalLight );

		var directionalLight = new THREE.DirectionalLight( 0xCC99FF, .3 );
		directionalLight.position.set( 0, 1, -.1);
		scene.add( directionalLight );

		var directionalLight = new THREE.DirectionalLight( 0xCC99FF, .6 );
		directionalLight.position.set( .1, 1, 1 );
		scene.add( directionalLight );

		var directionalLight = new THREE.DirectionalLight( 0x99CC88, .6 );
		directionalLight.position.set( -.10, 1, 1 );
		scene.add( directionalLight );

		var directionalLight = new THREE.PointLight( 0xffffff, -.7 );
		directionalLight.position.set( 0, 0, 0);
		scene.add( directionalLight );

		rotateParent = new THREE.Object3D();
		//scene.add(rotateParent);


		geometry = new THREE.Geometry();
		geometry.name = "Liz_Line";
		verts=weave({scale:25,offset:8});

		radius = "5";
		radius *= 0.5;

		for(var i = 0 ; i < verts.length ; i +=3){
			geometry.vertices.push(new THREE.Vector3((verts[i]),(verts[i+1]),(verts[i+2])));
		}



		var curve = new THREE.SplineCurve3(geometry.vertices);
		var geo = new THREE.TubeGeometry(curve, geometry.vertices.length*5, 12, 3, closed);
		tubeMesh = THREE.SceneUtils.createMultiMaterialObject(geo, [new THREE.MeshLambertMaterial({color: 0xffffff})]);

		tubeMesh.name = tubeMesh;
		tubes.push(tubeMesh);

		var rotateChild = new THREE.Object3D();
		rotateChild.add(tubeMesh);

		rotateParent.add(rotateChild);  

		//rotateParent.add(geometry);
		rotateParent.name = "rotateParent";
		scene.add(rotateParent);

		reGeoParent = new THREE.Object3D();
		reGeoParent.name = "reGeoParent";
		scene.add(reGeoParent);

		plane = new THREE.Mesh(new THREE.SphereGeometry(300,100,100),new THREE.MeshLambertMaterial( { color:0xFFFFFF, transparent:true, opacity:.0,emissive:0x99DDFF} ));
		plane.rotation.x = -1;
		plane.name = plane;
		console.log(plane);

		//scene.add(plane);

		var plane2 = new THREE.Mesh(new THREE.TorusGeometry(300,2,10,100),new THREE.MeshLambertMaterial( { color:0xFFFFFF, transparent:true, opacity:.5,emissive:0x999999} ));
		plane2.rotation.x=Math.PI;
		//scene.add(plane2);


		console.log(scene);
		width = window.innerWidth;
		height = window.innerHeight;

		camera = new THREE.PerspectiveCamera( 20, width/height, 500, 4000);
			//console.log(width/height);
			camera.position.set(0,0,2000);

		//camera = new THREE.OrthographicCamera( width /  2, width / -2, height / -2, height /  2, 1, 10000 );
		camParent = new THREE.Object3D();
		camera.lookAt(scene.position);

		//camera.position.set (0, 0, -1000);
		//camera.lookAt (new THREE.Vector3(0, 0, 0)); 
		camParent.add(camera);
		scene.add(camParent);

		//define material (blue line in this case)
		material = new THREE.LineBasicMaterial({
			color: 0x0000ff
		});

		// this.effect = new THREE.AnaglyphEffect( renderer,width,height );
		// effect.focalLength = 10;
		// effect.setSize( width, height );
	}

	document.addEventListener( 'mousemove', onDocumentMouseMove, false );
	document.addEventListener( 'mousedown', onDocumentMouseDown, false );
	document.addEventListener( 'mouseup', onDocumentMouseUp, false );
	//document.addEventListener('mousewheel',scrollFunc,false);


	function onDocumentMouseDown( event ) {
		if(event.clientY>20)
			draw = true;
	}
	function onDocumentMouseUp( event ) {
		if(event.clientY>20)
			draw = false;
	}

	window.onkeyup = onKeyUp;
	window.onkeypress = onKeyPress;

	function onFun(){
		fun = !fun;
		funColor();
		if(fun)draw=true;
		changeFun();

	}

	function onKeyPress(evt) {

		if (savingmode == false) {
			hirezGeo = false;
			console.log(evt.keyCode);
			if(evt.keyCode == 100){
				draw = true;
			}
			if(evt.keyCode == 114){
				rotator = true;
			}
			if(evt.keyCode == 108){
				ana = !ana;
			}
			if(evt.keyCode == 119){
				if(reGeoParent.children.length<1)
					saver2(tubeMesh,wScale*.0001);
				else
					saver2(reGeoParent,wScale*.0001);
			}
			if(evt.keyCode == 115){
				scaleGeo = true;
			}
			if(evt.keyCode == 102){
				onFun();
			}
			if(evt.keyCode == 103){
				game=true;
				draw=true;
				scaleGeometry(eval(funsc));
			}

			if(evt.keyCode == 97){
				averageVertices(geometry);
				if(rotateParent.children.length>0){
						removal();
				}
				updateGeo(9,radius,6);
			}
			//clear all
			if(evt.keyCode == 67){
				removal();
				killGeo();
			}
			if(evt.keyCode == 112){
				reGeo=!reGeo;
			}
			if(evt.keyCode == 110){
				noisy=!noisy;
			}
			//clear one
			if(evt.keyCode == 99){
				geometry.vertices.pop();
				if(rotateParent.children.length>0){
						removal();
				}
				updateGeo(9,radius,6);

			}
			if(evt.keyCode == 118){
				geometry.vertices.shift();
				if(rotateParent.children.length>0){
						removal();
				}
				updateGeo(9,radius,6);
			}
		}
	}


	instructions = function(){
		instruct=!instruct;
		if(instruct)
		document.getElementById('instruct').firstChild.nodeValue = "x,y,z and sc sections can be functions - use msin and mcos like this: msin(time*.5,-.2,.2) works well in the y field and then in x just use '.1' then in z try mnoise(time*.1) or for more control, mnoise(time*.1,.01,.1) and see what happens";
		else
		document.getElementById('instruct').firstChild.nodeValue = "-";
	}

	changeScale = function(){
		var tscale = document.getElementById('scale');
		if(tscale.value>-1e6 && tscale.value < 1e6){
			wScale = tscale.value;
			var overall = .01*(2*300*wScale)+"cm";
			var tubesize = .1*(2*radius*wScale)+"mm"
			document.getElementById('setscale').firstChild.nodeValue = overall + " " + tubesize;

		}
		else{
			alert("NaN or out of range");
		}

	}

	putValueIntoField = function(id,val){
		var field = document.getElementById('x');
		field.value = val;
	}

	changeFun = function(){
		var tfunx = document.getElementById('x');
		var tfuny = document.getElementById('y');
		var tfunz = document.getElementById('z');
		var tsc = document.getElementById('sc');

		funx = /*parseFloat(*/tfunx.value || "0";//);
		funy = /*parseFloat(*/tfuny.value || "0";//);
		funz = /*parseFloat(*/tfunz.value || "0";//);
		funsc= /*parseFloat(*/tsc.value || "1" ;//);

		try {
		 if(eval(funx)>-1e6 && eval(funx) < 1e6 && 
			eval(funy)>-1e6 && eval(funy) < 1e6 && 
			eval(funz)>-1e6 && eval(funz) < 1e6 &&
			eval(funsc)>-1e6 && eval(funsc) < 1e6){
				
			}	
		}
		catch(e){
			alert(e.message + " no fun for you");
			fun = false;
			draw = false;
			funColor();
			funx = /*parseFloat(*/"0";//);
			funy = /*parseFloat(*/"0";//);
			funz = /*parseFloat(*/"0";//);
			funsc= /*parseFloat(*/"0" ;//);
		}
	}

	callme = function(mess){
		alert(mess);
	}

	function noiseVerts(geo){
		if(geo!=undefined){
			if(geo.vertices && geo.vertices.length>0){
				//console.log(geo.vertices);
				if(rotateParent.children.length>0){
					removal();
				}
				for(var i = 0 ; i < geo.vertices.length ; i++){
					geo.vertices[i].x += .5*noise.noise(i*.051,i*.051);
					geo.vertices[i].y += .5*noise.noise(i*.051+100,i*.051);
					geo.vertices[i].z += .5*noise.noise(i*.051+200,i*.051);
				}

			}
		}
	}

	function mnoise(i,j,k){
		var q = j || 0 ;
		var p = k || 1 ;
		return map_range(noise.noise(i,i),0,1,q,p);
	}

	funColor = function(){
		if(fun){
	   document.getElementById("funbutton").setAttribute("style","background-color: #FFE0D1");
		}
		else {
		document.getElementById("funbutton").setAttribute("style","background-color: #6B96A4");
	}};

	changeThickness = function(){
		var tradius = document.getElementById('fat');
		if(tradius.value>-1e6 && tradius.value < 1e6){
			radius = tradius.value * 0.5;
			updateGeo(7,radius,9);

		}
		else{
			alert("NaN or out of range");
		}
	}

	function onKeyUp(evt) {

		rotator = false;
		scaleGeo = false;
		game = false;
		if(!fun&&!game){
			hirezGeoSwitcher=true;
			draw = false;
		}
	}

	function printVerts(){
		console.log("clicked to printVerts");
		savingmode = true;

		for(q in geometry.vertices){
			sverts += (geometry.vertices[q].x +"," + geometry.vertices[q].y+"," + geometry.vertices[q].z+",");
		}
		document.getElementById('designTextArea').value = sverts;

		var metadata = funx + "|" + funy + "|" + funz + "|" + funsc + "|" + radius + "|" + wScale;
		document.getElementById('metaData').value = metadata;		
		console.log("metadata: "+ metadata);

		var dataUrl = renderer.domElement.toDataURL("image/png");
		document.getElementById('imageData').value = dataUrl;
		
	}
	
	function removal(num){
		var n = num || 0;

		for (var i = rotateParent.children.length-1 ; i >= n ; i--){
			//scene.remove(rotateParent.children[i]);//tubes[i]);
			if(reGeo)
				rotateParent.remove(rotateParent.children[i]);
			else
				reGeoParent.add(rotateParent.children[i]);
		}
	}

	function killGeo(){
		while(geometry.vertices.length>0)
		geometry.vertices.pop();
		scene.remove(reGeoParent);
		reGeoParent = new THREE.Object3D();
		scene.add(reGeoParent);
		console.log(reGeoParent.children);
	}

	function onDocumentMouseMove(event) {

		hirezGeo = false;

		x=event.clientX;
		y=event.clientY-20;

		if(rotator){
			rotateGeometry(x,y,0,true);
			
		}
		else if(scaleGeo){
			scaleGeometry(geoSX +=(y-sty[0])*0.001);

		}
		

		geoSX = 1;
	}

	function drawLine(){

			var projector = new THREE.Projector();
		
		    var vector = new THREE.Vector3(
		    ( x / width)*2 -1,// * 2 - 1,
		    - ( y / height) *2 + 1,// * 2 + 1,
		    -1000 );

		    var ray = projector.pickingRay( vector, camera );

		    var intersect = ray.intersectObject( plane ); 

		    if ( intersect.length > 0) { 

		    	pPos = new THREE.Vector3(intersect[0].point.x,intersect[0].point.y,intersect[0].point.z);

		    	if(geometry.vertices.length==0)
		    		geometry.vertices.push(pPos);
		    	else if(pPos.x!=geometry.vertices[geometry.vertices.length-1].x )
		        	geometry.vertices.push(pPos);
		    	

		        var tempRotatorer = new THREE.Object3D();

				if(rotateParent.children.length>0){
					removal();
				}

				
		    }
	}

	function rotateGeometry(tx,ty,tz,mouse){

		var mouseMove = mouse;

		var parms = [];

		if(mouseMove){
			parms.rx = (ty-sty[0])*-0.011;
			parms.ry = (tx-stx[0])*-0.011;
			parms.rz = 0;
		}
		else{
			parms.rx = ty;
			parms.ry = tx;
			parms.rz = tz;
		}

		if(reGeo){
			reGeoParent.rotation.x -= parms.rx;
			reGeoParent.rotation.y -= parms.ry;
		}

		for(var i = 0 ; i < geometry.vertices.length ; i++){

			var obj = geometry.vertices[i];

			var parms2 = [];
			parms2.x = obj.x;
			parms2.y = obj.y;
			parms2.z = obj.z;

			var newMat = jMatMult(makeMatrix(parms2),makeMatrix(parms));
			//console.log(newMat);

			obj.x = newMat[12];
			obj.y = newMat[13];
			obj.z = newMat[14];
			
		}

		if(rotateParent.children.length>0){
				removal();
		}

	}

	function scaleGeometry(geoSX){

			
				
			var parms = [];
			parms.sx = geoSX;
			parms.sy = geoSX;
			parms.sz = geoSX;

			for(var i = 0 ; i < geometry.vertices.length ; i++){

				var obj = geometry.vertices[i];

				var parms2 = [];
				parms2.x = obj.x;
				parms2.y = obj.y;
				parms2.z = obj.z;

				var newMat = jMatMult(makeMatrix(parms2),makeMatrix(parms));
				//console.log(newMat);

				obj.x = newMat[12];
				obj.y = newMat[13];
				obj.z = newMat[14];
				
			}

			if(reGeo){
				reGeoParent.scale.x *= geoSX;
				reGeoParent.scale.y *= geoSX;
				reGeoParent.scale.z *= geoSX;
			}

			if(rotateParent.children.length>0){
					removal();
			}

			//updateGeo(1,radius,4);

	}

	function averageVertices(geo){

		for(var j = 0 ; j < geo.vertices.length ; j++){

			var small = new THREE.Vector3(0,0,0);
			var big = new THREE.Vector3(0,0,0);

			for(var i = -1 ; i < 2 ; i++){

				if(j>1&&j<geo.vertices.length-2){
					small.x += geo.vertices[j+i].x;
					small.y += geo.vertices[j+i].y;
					small.z += geo.vertices[j+i].z;
				
				}
			}

			small.x/=3;
			small.y/=3;
			small.z/=3;
			
				if(j>1&&j<geo.vertices.length-2){
					geo.vertices[j]=small;
				}
			
		}

	}

	function updateGeo(detail,size,rad){

		var d = detail 	|| 2;
		var s = size 	|| 5;
		var r = rad 	|| 3;

		//averageVertices(geometry);

		var line = new THREE.Line(geometry, material);

				
		var curve = new THREE.SplineCurve3(geometry.vertices);
		var geo = new THREE.TubeGeometry(curve, geometry.vertices.length*d, s, r, closed);
		
		var small = new THREE.Vector3(0,0,0);
		var big = new THREE.Vector3(0,0,0);

		for(var i = 0 ; i < rad ; i++){
			small.x += geo.vertices[i].x;
			small.y += geo.vertices[i].y;
			small.z += geo.vertices[i].z;
			big.x += geo.vertices[geo.vertices.length-1-i].x;
			big.y += geo.vertices[geo.vertices.length-1-i].y;
			big.z += geo.vertices[geo.vertices.length-1-i].z;

		}
		small.x/=rad;
		small.y/=rad;
		small.z/=rad;

		big.x/=rad;
		big.y/=rad;
		big.z/=rad;

		geo.mergeVertices();

		for(var i = 0 ; i < rad ; i++){
			geo.vertices[i]=small;
			geo.vertices[geo.vertices.length-1-i]=big;
		}


		tubeMesh = new THREE.Mesh(geo,new THREE.MeshLambertMaterial({color: 0xffffff}));//THREE.SceneUtils.createMultiMaterialObject(geo, [new THREE.MeshLambertMaterial({color: 0xffffff})]);

		tubeMesh.name = "tubeMesh";
		//tubes.push(tubeMesh);
		//scene.add(tubeMesh);  
		
		
		var rotatorer = new THREE.Object3D();
		//rotatorer.rotation = tempRotatorer.rotation;
		//console.log(rotatorer.rotation.x);
		rotatorer.name = "rotateChild";

		rotatorer.add(tubeMesh);
		rotateParent.add(rotatorer);

	}

	function animate() {

		//textColorChange();

		if(draw && count == 0){
			drawLine();
		}

		hirezGeo=true;
		updateMouse(x,y);

		if(draw||rotator||game||scaleGeo||fun || noisy){
			if(geometry.vertices.length>0)
				updateGeo(1,radius,5);
		}
		else
			hirezGeo=true;

		count++;
		time+=Math.PI/3;
		//console.log(count);
		if(count%2==0)
			count=0;

		setTimeout( function() {

        	requestAnimationFrame( animate );

   		 }, 1000 / 30 );

		if(ana)
		effect.render( scene, camera );
		else
		renderer.render(scene,camera);

		if(!draw && !rotator && hirezGeo && hirezGeoSwitcher){
			//console.log(rotateParent.children.length);
			if(rotateParent.children.length>0){
				removal();
			}
			//console.log(rotateParent.children.length);
			if(geometry.vertices.length>0)
				updateGeo(7,radius,9);

			hirezGeo=false;
			hirezGeoSwitcher = false;
		}
		if(fun){
			draw=true;
			try{
			rotateGeometry(eval(funx),eval(funy),eval(funz),false);
			scaleGeometry(eval(funsc));
			}
			catch(e){
				alert("nope" + e.message);
			}
			
		}
		if(game){
			rotateGeometry(.2*(((x/width)*2)-1),.2*(((y/height)*2)-1),0,false);
		}
		if(noisy)
		noiseVerts(geometry);
	}

	function updateMouse(x,y){
		stx.push(x);
		sty.push(y);
		if(stx.length>1){
			stx.shift();
			sty.shift();
		}

	}


	function weave(params){

		//this function will return an array of x,y,z coordinates where each index is as such:
		//[x,y,z,x,y,z,x,y,z...]
		
		var verts = [];

		if(!params) params={};

		var c   = params.depth || 5; //height (Z) of the weave
		var sc  = params.scale || 20; // X,Y scale of the weave
		var off = params.offset || 5; // controls the smoothness of the weave - 0 would be square, 10 triangular
		var col = params.rows || 20;
		var row = params.rows || 20;

		for (var i = -col/2; i < col/2; i++) {
			//count forward for even rows and backwards for odd rows
			if(i%2==0){
				for (var j = -(row/2)-1; j < row/2; j++) {
					//as we travel across push two vectors for each j step
					//every other step should either move up or down to accomplish weaving
					//without the offset ("off") the weave would be square
					if(j%2==0){
						verts.push(i*sc);
						verts.push(-off+j*sc);
						verts.push(c);  //notice the variation from c to 0
						verts.push(i*sc);
						verts.push(off+j*sc);
						verts.push(0);
					}
					else{
						verts.push(i*sc);
						verts.push(-off+j*sc);
						verts.push(0);	//and from 0 to c (up and down)
						verts.push(i*sc);
						verts.push(off+j*sc);
						verts.push(c);
					}
				}
			//push an extra vertex on at the end of a row to avoid a sawtooth pattern
			verts.push(i*sc);
			verts.push(j*sc);
			verts.push(0);
			}
			else{
				for (var j = row/2; j >-(row/2)-1; j--) {
					if(j%2==0){
						verts.push(i*sc);
						verts.push(off+j*sc);
						verts.push(c);
						verts.push(i*sc);
						verts.push(-off+j*sc);
						verts.push(0);
					}
					else{
						verts.push(i*sc);
						verts.push(off+j*sc);
						verts.push(0);
						verts.push(i*sc);
						verts.push(-off+j*sc);
						verts.push(c);
					}
				}
			verts.push(i*sc);
			verts.push(j*sc);
			verts.push(0);
			}
		}
		//this loop is identical to the above but weaves in the other direction
		for (var i = -col/2; i < (col/2)+1; i++) {
			if(i%2==0){
				for (var j = row/2; j >-row/2; j--) {
					if(j%2==0){
						//I offset these rows by "sc/2" (scale/2) 
						//so the rows overlap
						verts.push((-sc/2)+off+j*sc);
						verts.push((-sc/2)+i*sc);
						verts.push(0);
						verts.push((-sc/2)-off+j*sc);
						verts.push((-sc/2)+i*sc);
						verts.push(c);
					}
					else{
						verts.push((-sc/2)+off+j*sc);
						verts.push((-sc/2)+i*sc);
						verts.push(c);
						verts.push((-sc/2)-off+j*sc);
						verts.push((-sc/2)+i*sc);
						verts.push(0);
					}
				}
			verts.push((-sc/2)+j*sc);
			verts.push((-sc/2)+i*sc);
			verts.push(0);
			}
			else{
				for (var j = -row/2; j < row/2; j++) {
					if(j%2==0){
						verts.push((-sc/2)-off+j*sc);
						verts.push((-sc/2)+i*sc);
						verts.push(0);
						verts.push((-sc/2)+off+j*sc);
						verts.push((-sc/2)+i*sc);
						verts.push(c);
					}
					else{
						verts.push((-sc/2)-off+j*sc);
						verts.push((-sc/2)+i*sc);
						verts.push(c);
						verts.push((-sc/2)+off+j*sc);
						verts.push((-sc/2)+i*sc);
						verts.push(0);
					}
				}
			verts.push((-sc/2)+j*sc);
			verts.push((-sc/2)+i*sc);
			verts.push(c);
			}
		}

		var str = "";
		for (var i = verts.length - 1; i >= 0; i--) {
			str+="," + verts[i];
		};
		console.log(str);

		return verts;

	}


	</script>

	<script>


	</script>

	
</div> <!-- end div main -->
	</body>
</html>