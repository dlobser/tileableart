<html>
  <head>

  	<style>

	body{
		margin:0;
		padding:0;
	}
	body {
        overflow: hidden;
    }
    </style>

    <title>objLoader</title>
    <body>

		<div id="container"></div>
		<script src="js/three.min.js"></script>
		<script src="js/OrbitControls.js"></script>
		<script src="js/OBJLoader.js"></script>

		<script>
	
			var camera, controls, scene, renderer;

			var omouseX = omouseY = 0;

			var counter = 0;

			var thing = [];


			function skinTube(params){

				var args = params || {};
				this.radSegs = args.radSegs || 4;
				this.heightSegs = args.heightSegs || 100;

				this.mat = args.material || new THREE.MeshLambertMaterial({side:THREE.DoubleSide,color:0x999999,skinning:true,wireframe:false});
				
				

				this.skinTubes = [];
				this.skinParent = new THREE.Object3D();

				this.base = new THREE.Object3D();
		        this.rot = new THREE.Object3D();
		        this.Up = new THREE.Object3D();
		        this.Up.position.y=10;
		        this.base.add(this.rot);
		        this.base.add(this.Up);
		        this.rot.rotation.x=Math.PI/2;
		        this.aim = new THREE.Object3D();

		      
		        this.makeGeo = function(){
		        	this.geo = new THREE.CylinderGeometry(1,1,1,this.radSegs,this.heightSegs,true);
					this.cap = new THREE.SphereGeometry( 1, this.radSegs, 10, 0, Math.PI*2, 0, Math.PI/2 );
					for(var i = 0 ; i < this.cap.vertices.length ; i++){
						this.cap.vertices[i].y*=-1;
						this.cap.vertices[i].y-=.5;
					}
					for(var i = 0 ; i < this.cap.faces.length ; i++){
						var temp = this.cap.faces[i].a;
						this.cap.faces[i].a = this.cap.faces[i].c;
						this.cap.faces[i].c = temp;
					}

					this.cap2 = this.cap.clone();

					var mat = new THREE.Matrix4();
					mat.makeRotationX(Math.PI);
					for(var i = 0 ; i < this.cap2.vertices.length ; i++){
						this.cap2.vertices[i].applyMatrix4(mat);
					}
					for(var i = 0 ; i < this.cap2.faces.length ; i++){
						var temp = this.cap.faces[i].a;
						this.cap2.faces[i].a = this.cap.faces[i].c;
						this.cap2.faces[i].c = temp;
					}

					THREE.GeometryUtils.merge(this.geo,this.cap);
					THREE.GeometryUtils.merge(this.geo,this.cap2);
					this.geo.computeFaceNormals();
					this.geo.computeVertexNormals();

		        };

		        this.makeGeo();

				this.init = function(n,s){

					var amount = n || 1;

					for(var q = 0 ; q < amount ; q++){

				        this.geo.skinIndices = [];
				        this.geo.skinWeights = [];
				        this.geo.bones = [];

				        var capCount = 0;

				        var j = 0;
				        var tBone = 0;

				        for(var i = 0 ; i < this.geo.vertices.length ; i++){

				        	if(i<(this.radSegs*this.heightSegs)+this.radSegs+this.heightSegs){

					        	if(j%(this.radSegs+1)==0){
					        		j=0;
					        		tBone++;
					        	}

					        	if(j==0){
					        		var b = this.makeBone(tBone,this.geo.vertices[i].y)
					        		this.geo.bones.push(b);
					        	}

					            this.geo.skinIndices.push( new THREE.Vector4(tBone,0,0,0 ));
					            this.geo.skinWeights.push( new THREE.Vector4(1,0,0,0 ));

					            j++;

					        }
					        else if(capCount<this.cap.vertices.length+1){
					        	this.geo.skinIndices.push( new THREE.Vector4(tBone,0,0,0 ));
					            this.geo.skinWeights.push( new THREE.Vector4(1,0,0,0 ));
					            capCount++;
					        }
					        else{
					        	this.geo.skinIndices.push( new THREE.Vector4(1,0,0,0 ));
					            this.geo.skinWeights.push( new THREE.Vector4(1,0,0,0 ));
					        }

				        }

				        var tube = new THREE.SkinnedMesh(this.geo,this.mat,false);
				        this.skinParent.add(tube);
				        this.skinTubes.push(tube);
				        
				    }

				    return this.skinParent;

			    };

			    this.update = function(curve,index){

			    	var i = index || 0;

			    	vUp = new THREE.Vector3(0,-1,0);

			    	for(var j = 0 ; j < this.skinTubes[i].children.length ; j++){

		
		    			var aVec =  curve.getPointAt(((j/this.skinTubes[i].children.length)*1));
		    			var vec = curve.getPointAt((j/this.skinTubes[i].children.length)*1+.0001);
		    			copyVec(this.base.position,vec);
		    			copyVec(this.aim.position,aVec);
		    			this.base.up = vUp;
		    			this.base.lookAt(this.aim.position);
		    			this.base.updateMatrixWorld();

		    			var q = this.rot.getWorldRotation();

		    			this.skinTubes[i].children[j].position.x = vec.x;
		    			this.skinTubes[i].children[j].position.y = vec.y;
		    			this.skinTubes[i].children[j].position.z = vec.z;
		    			this.skinTubes[i].children[j].rotation.x = q.x;
		    			this.skinTubes[i].children[j].rotation.y = q.y;
		    			this.skinTubes[i].children[j].rotation.z = q.z;
		    			
		    			vUp.setFromMatrixPosition(this.Up.matrixWorld);

		    		}

			    };


		        this.makeBone = function(num,pos){

		        	var bone = {};

			        bone.name="bone"+num;
			        bone.pos = [0,pos,0];
			        bone.rot = [0,0,0];
			        bone.scl = [1,1,1];
			        bone.rotq = [0,0,0,1];
			        bone.parent = -1;

			        return bone;

		        }

			}


			sc1 = {
    
			    setup:function(){

			        frameRate = 1;

			        t = new skinTube();
			        scene.add(t.init(50));

			        cs = [];


			        for(var j = 0 ; j < 100 ; j++){
	        	        var v = [];

	        	        var X = 50-Math.random()*100;
	        	        var Y = -Math.random()*100;
	        	        var Z = 5-Math.random()*50;

	                    for ( var q = 0 ; q < 15 ; q++){
	                    	X+=0;//10-Math.random()*20;
	                    	Y+=q;//10-Math.random()*20;
	                    	Z+=0;//2.5-Math.random()*5;
	                    	v.push(new THREE.Vector3(X,Y,Z));
	                    }

	                    c = new THREE.SplineCurve3(v);

	                    cs.push(c);
	                }




       		  //       var v = [];

       	   //          for ( var q = 0 ; q < 5 ; q++){
       	   //          	v.push(new THREE.Vector3(Math.random()*40,Math.random()*40,Math.random()*40));
       	   //          }

       	   //          c = new THREE.SplineCurve3(v);

   			   		// t.update(c)

			    	   count=0;
			    },

			    draw:function(time){

			    	var m = new THREE.Vector3(omouseX*200,-omouseY*200,0);

			    	count++;
			    	// cs[0].points[0].x=omouseX*20;
			    	// t.update(cs[0],0)

			    	// t.skinTubes[0].children[1].position.x = omouseX*20;
			    	// 			    	t.skinTubes[0].children[t.skinTubes[0].children.length-1].rotation.x = omouseX*3;


			    	for(var i = 0 ; i < t.skinTubes[0].children.length ; i++){
			    		t.skinTubes[0].children[i].position.x = Math.sin(i*.1+count*.1);
			    	}
			    	for(var i = 0 ; i < t.skinTubes.length ; i++){

				   		t.update(cs[i],i);
				   	}

				   	for(var i = 0 ; i < cs.length ; i++){
				   		var X = 0;
				   		var Y = 0;
				   		var Z = 0;
				   		var Mat = new THREE.Matrix4();
				   		var Mat2 = new THREE.Matrix4();

				   		for(var j = 0 ; j < cs[i].points.length ; j++){
				   			
				   			// var b = m.clone();
				   			var dist = cs[i].points[j].distanceTo(m);
				   			var d2 = Math.max(0,THREE.Math.mapLinear(dist,0,50,50,0))*.001;
				   			Mat.makeRotationZ(d2);
				   			Mat.elements[12]=m.x;
				   			Mat.elements[13]=m.y;
				   			Mat.elements[14]=m.z;
				   			
				   			Mat2.elements[12]=-m.x;
				   			Mat2.elements[13]=-m.y;
				   			Mat2.elements[14]=-m.z;
				   			cs[i].points[j].applyMatrix4(Mat2);
				   			// b.multiplyScalar(Math.max(0,THREE.Math.mapLinear(dist,0,50,50,0))*.1);
				   			// var q = cs[i].points[j].clone();
				   			// var g = q.sub(b);

				   			// if(dist<50)
				   			// 	cs[i].points[j].add(g);//+=Z;
				   			X+=.5-Math.random();
				   			Y+=.5-Math.random();
				   			Z+=.5-Math.random();
				   			cs[i].points[j].x+=X*d2;
				   			cs[i].points[j].y+=Y*d2;
				   			cs[i].points[j].z+=Z*d2;
				   			cs[i].points[j].applyMatrix4(Mat);
				   			

				   		}
				   	}
			    }
			}

			function copyVec(a,b){
				a.x = b.x;
				a.y = b.y;
				a.z = b.z;
			}


			init();
			animate();

			function init() {

				camera = new THREE.PerspectiveCamera( 30, window.innerWidth / window.innerHeight, 1, 10000 );

				camera.position.z = 290;

				controls = new THREE.OrbitControls( camera );

				scene = new THREE.Scene();
				

				light = new THREE.DirectionalLight( 0xffffff );
				light.position.set( 1, 1, .5 ); scene.add( light );
				
				light = new THREE.DirectionalLight( 0x555555 );
				light.position.set( -1, 1, .5 ); scene.add( light );
				
				light = new THREE.DirectionalLight( 0x555555 );
				light.position.set( 0, 1, 1 ); scene.add( light );
				
				light = new THREE.DirectionalLight( 0x666666 );
				light.position.set( 0, 1, -1 ); scene.add( light );

				light = new THREE.DirectionalLight( 0x334477,1,0 );
				light.position.set( -1, -1, -1 ); scene.add( light );
				
				light = new THREE.DirectionalLight( 0x556699,1,0 );
				light.position.set( 1, -1, 1 ); scene.add( light );

				light = new THREE.AmbientLight( 0x222222 ); scene.add( light );

				renderer = new THREE.WebGLRenderer( { clearColor: 0xff0000, antialias: true } );
				renderer.setClearColor( 0x000000, 0 );
				renderer.setSize( window.innerWidth, window.innerHeight );
				
				container = document.getElementById( 'container' );
				container.appendChild( renderer.domElement );

				window.addEventListener( 'resize', onWindowResize, false );

				sc1.setup();


			}

			function onWindowResize() {
			
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();
				renderer.setSize( window.innerWidth, window.innerHeight );
			}

			function animate() {
				counter++;
				render();
				requestAnimationFrame( animate );
				controls.update();
				
			}
			
			function render() {
				
				sc1.draw();
				renderer.render( scene, camera );

			}
				
			window.onkeyup = onKeyUp;
			
			function onKeyUp(evt) {

				if(evt.keyCode == 65){
					thing[0].position.y -= 30;
				}
				if(evt.keyCode == 81){
					thing[0].position.y += 30;
				}
			}

			window.onmousemove = function(event) { // Mouse moved
				moveMouse(this.handle, event);
			}

			function moveMouse(handle, event) {
				var x = event.clientX;
				var y = event.clientY;

				var rect = event.target.getBoundingClientRect();
				if ( rect.left <= x && x <= rect.right &&
				  	rect.top  <= y && y <= rect.bottom ) {
					rmouseX = x;
					rmouseY = y;
					mouseX = x / rect.right;
					mouseY = y / rect.bottom;
					omouseX = mouseX-.5;
					omouseY = mouseY-.5;

				}
			}

			
		
		</script>
	</body>
</html>
