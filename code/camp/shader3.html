<html>
  <head>

  	<style>

	body{
		margin:0;
		padding:0;
	}
	body {
        overflow: hidden;
    }
    </style>

    <title>objLoader</title>
    <body>

		<div id="container"></div>
		<script src="js/three.min.js"></script>

		<script src="js/OrbitControls.js"></script>

		<script>

			sc1 = {
		
				setup:function(){

										var sphGeo = new THREE.SphereGeometry(1,90,90);
					sphere1 = new THREE.Mesh(sphGeo,camNormReflShader);

					scene.add(sphere1);
					console.log(camera);
					count=0;

				},

				draw:function(){

					count++;

					// plane.material.uniforms['time'].value=count*.01;
					sphere1.material.uniforms['camMat'].value = camera.matrixWorld;
					// camera.updateMatrixWorld();
					sphere1.material.uniforms['switcher'].value =0;

				}
			};


			var noise = "\
			vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\
			vec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\
			vec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\
			vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\
			vec3 fade(vec3 t) { return t*t*t*(t*(t*6.0-15.0)+10.0); }\
			float noise(vec3 P) {\
				vec3 i0 = mod289(floor(P)), i1 = mod289(i0 + vec3(1.0));\
				vec3 f0 = fract(P), f1 = f0 - vec3(1.0), f = fade(f0);\
				vec4 ix = vec4(i0.x, i1.x, i0.x, i1.x), iy = vec4(i0.yy, i1.yy);\
				vec4 iz0 = i0.zzzz, iz1 = i1.zzzz;\
				vec4 ixy = permute(permute(ix) + iy), ixy0 = permute(ixy + iz0), ixy1 = permute(ixy + iz1);\
				vec4 gx0 = ixy0 * (1.0 / 7.0), gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;\
				vec4 gx1 = ixy1 * (1.0 / 7.0), gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;\
				gx0 = fract(gx0); gx1 = fract(gx1);\
				vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0), sz0 = step(gz0, vec4(0.0));\
				vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1), sz1 = step(gz1, vec4(0.0));\
				gx0 -= sz0 * (step(0.0, gx0) - 0.5); gy0 -= sz0 * (step(0.0, gy0) - 0.5);\
				gx1 -= sz1 * (step(0.0, gx1) - 0.5); gy1 -= sz1 * (step(0.0, gy1) - 0.5);\
				vec3 g0 = vec3(gx0.x,gy0.x,gz0.x), g1 = vec3(gx0.y,gy0.y,gz0.y),\
					 g2 = vec3(gx0.z,gy0.z,gz0.z), g3 = vec3(gx0.w,gy0.w,gz0.w),\
					 g4 = vec3(gx1.x,gy1.x,gz1.x), g5 = vec3(gx1.y,gy1.y,gz1.y),\
					 g6 = vec3(gx1.z,gy1.z,gz1.z), g7 = vec3(gx1.w,gy1.w,gz1.w);\
				vec4 norm0 = taylorInvSqrt(vec4(dot(g0,g0), dot(g2,g2), dot(g1,g1), dot(g3,g3)));\
				vec4 norm1 = taylorInvSqrt(vec4(dot(g4,g4), dot(g6,g6), dot(g5,g5), dot(g7,g7)));\
				g0 *= norm0.x; g2 *= norm0.y; g1 *= norm0.z; g3 *= norm0.w;\
				g4 *= norm1.x; g6 *= norm1.y; g5 *= norm1.z; g7 *= norm1.w;\
			vec4 nz = mix(vec4(dot(g0, vec3(f0.x, f0.y, f0.z)), dot(g1, vec3(f1.x, f0.y, f0.z)),\
							   dot(g2, vec3(f0.x, f1.y, f0.z)), dot(g3, vec3(f1.x, f1.y, f0.z))),\
						  vec4(dot(g4, vec3(f0.x, f0.y, f1.z)), dot(g5, vec3(f1.x, f0.y, f1.z)),\
							   dot(g6, vec3(f0.x, f1.y, f1.z)), dot(g7, vec3(f1.x, f1.y, f1.z))), f.z);\
				return 2.2 * mix(mix(nz.x,nz.z,f.y), mix(nz.y,nz.w,f.y), f.x);\
			}\
			float noise(vec2 P) { return noise(vec3(P, 0.0)); }\
			float turbulence(vec3 P) {\
				float f = 0., s = 1.;\
			for (int i = 0 ; i < 9 ; i++) {\
			   f += abs(noise(s * P)) / s;\
			   s *= 2.;\
			   P = vec3(.866 * P.x + .5 * P.z, P.y, -.5 * P.x + .866 * P.z);\
			}\
				return f;\
			}\
			";

			var bumpVert = "\
				varying vec3 vecNormal;\
				varying vec3 pos;\
				varying vec2 vUv;\
				varying vec3 wNormal;\
				uniform float switcher;\
				uniform sampler2D tex;\
				uniform sampler2D tex2;\
				uniform sampler2D tex3;\
				void main() {\
					vUv = uv;\
					pos = position;\
					vecNormal = normal;\
					wNormal = mat3(modelMatrix[0].xyz,modelMatrix[1].xyz,modelMatrix[2].xyz)*normal;\
					wNormal = normalize(wNormal);\
					gl_Position = projectionMatrix *\
					modelViewMatrix * vec4(position, 1.0 );\
				}\
			";

			camSpaceReflNorm = "\
				precision highp float;\
				uniform mat4 camMat;\
				varying vec3 wNormal;\
				varying vec3 vecNormal;\
				varying vec2 vUv;\
				varying vec3 pos;\
				uniform sampler2D tex;\
				uniform sampler2D tex2;\
				uniform sampler2D tex3;\
				uniform float switcher;\
				vec3 reflRay(vec3 dir, vec3 norm) {\
					vec3 ray;\
					float ldn = dot(dir, norm);\
			       	vec3 refl = 2. * ldn * norm - dir;\
					return refl;\
				}\
				void main(void) {\
					float mult = 51.;\
					float Noise = (noise(pos*mult))*.1;\
					float off = .000001;\
					float px = ((noise(vec3(mult*pos.x+off,mult*pos.y,mult*pos.z))*.15)-Noise);\
					float py = ((noise(vec3(mult*pos.x,mult*pos.y+off,mult*pos.z))*.15)-Noise);\
					float pz = ((noise(vec3(mult*pos.x,mult*pos.y,mult*pos.z+off))*.15)-Noise);\
					vec3 nNormal = normalize(vecNormal-vec3(px,py,pz));\
					vec4 camNorm = vec4(vec3(nNormal),0.) * camMat;\
					vec3 refl = reflRay(normalize(camMat[3].xyz),nNormal.xyz);\
					float n = turbulence(refl);\
					vec3 img2 = texture2D(tex, vec2(.5+(refl.x*.5),.5+(refl.y*.5)) ).xyz;\
					vec3 img4 = texture2D(tex2, vec2(.5+(refl.x*.5),.5+(refl.y*.5)) ).xyz;\
					vec3 img3 = texture2D(tex3, vec2(.5+(refl.x*.5),.5+(refl.y*.5)) ).xyz;\
					vec3 img = vec3(.5);\
					float cz = (camNorm.z*-1.)+1.;\
					if(switcher<.5)\
						gl_FragColor = vec4(.3+camNorm.z*.2+(pow(cz,2.)*img4*2.+pow(cz,3.)*img2*5.)+camNorm.z*img3*.3, 1.0);\
					else\
						gl_FragColor = vec4(img, 1.0);\
				}\
			";


			camNormReflShader = new THREE.ShaderMaterial({
				uniforms:
				{	
					camMat: {type: 'm4', value:new THREE.Matrix4()},
					switcher: {type:'f', value:0},
					tex : {type:'t', value: THREE.ImageUtils.loadTexture( "textures/refl_off.jpg" )},
					tex2 : {type:'t', value: THREE.ImageUtils.loadTexture( "textures/refl_littleBlur_off.jpg" )},
					tex3 : {type:'t', value: THREE.ImageUtils.loadTexture( "textures/refl_superBlur_off.jpg" )}
				},
				vertexShader: bumpVert,
				fragmentShader: noise+camSpaceReflNorm,
			});




		</script>

		<script>
	
			var camera, controls, scene, renderer;

			var thing = [];

			init();
			animate();
			
			// window.addEventListener('load', function() { animate();}, false)

			function init() {

				camera = new THREE.PerspectiveCamera( 30, window.innerWidth / window.innerHeight, 1, 10000 );

				camera.position.z = 20;

				controls = new THREE.OrbitControls( camera );

				scene = new THREE.Scene();

				light = new THREE.DirectionalLight( 0x999999 );
				light.position.set( 1, 1, .5 ); scene.add( light );
				
				light = new THREE.DirectionalLight( 0x555555 );
				light.position.set( -1, 1, .5 ); scene.add( light );
				
				light = new THREE.DirectionalLight( 0x555555 );
				light.position.set( 0, 1, 1 ); scene.add( light );
				
				// light = new THREE.DirectionalLight( 0x666666 );
				// light.position.set( 0, 1, -1 ); scene.add( light );

				light = new THREE.DirectionalLight( 0x334477,1,0 );
				light.position.set( -1, -1, -1 ); scene.add( light );
				
				light = new THREE.DirectionalLight( 0x556699,1,0 );
				light.position.set( 1, -1, 1 ); scene.add( light );

				// light = new THREE.AmbientLight( 0x222222 ); scene.add( light );

				renderer = new THREE.WebGLRenderer( { clearColor: 0xff0000, antialias: true } );
				renderer.setClearColor( 0x000000, 0 );
				renderer.setSize( window.innerWidth, window.innerHeight );
				
				container = document.getElementById( 'container' );
				container.appendChild( renderer.domElement );

				window.addEventListener( 'resize', onWindowResize, false );

				sc1.setup();


			}

			function onWindowResize() {
			
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();
				renderer.setSize( window.innerWidth, window.innerHeight );
			}

			function animate() {
			
				render();
				requestAnimationFrame( animate );
				controls.update();
				
			}
			
			function render() {
				
				sc1.draw();
				renderer.render( scene, camera );

			}
				
			window.onkeyup = onKeyUp;
			
			function onKeyUp(evt) {

				if(evt.keyCode == 65){
					thing[0].position.y -= 30;
				}
				if(evt.keyCode == 81){
					thing[0].position.y += 30;
				}
			}


		
		</script>

	
	</body>
</html>
