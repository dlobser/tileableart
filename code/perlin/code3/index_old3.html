<!! ASSIGNMENT DUE WEDNESDAY SEPTEMBER 18, 2013 FOR KEN PERLIN'S GRAPHICS CLASS>

<script src="script.js"></script>

<!! REPLACE THE TEXT BELOW WITH A TITLE FOR YOUR SHADER>

<script id="title" type="text/plain">
Chinese Medicine Balls
</script>

<!! REPLACE THE TEXT BELOW WITH A BRIEF DESCRIPTION OF YOUR SHADER>

<script id="description" type="text/plain">

Because one ball is never enough.

</script>

<!! REPLACE THE TEXT BELOW WITH YOUR SHADER CODE>

<script id="shader" type="x-shader/x-fragment">
                                                                           
                                                                     
                                                                     
                                             
//define sphere positions and scale
vec4 sph1 = vec4(sin(uTime), cos(uTime)*0.5, sin(uTime)*-2.,
abs(sin(uTime*5.5)+5.0)*0.15);
vec4 sph2 = vec4(sin(uTime+3.14), cos(uTime+3.14), 0.0,
abs(sin(uTime*5.0)+5.0)*0.15);

vec4 cyl = vec4(0.0,0.0,0.0,1.0);  //if w is 1 it's a point

vec4 cube[6];
float tEnter[6];
float tExit[6];

mat4 tsMatrix(vec3 t, vec3 s) {
        return mat4(s.x,0.,0.,0., 0.,s.y,0.,0., 0.,0.,s.z,0., t.x,t.y,t.z,1.);
}
mat4 rotmatYaxis(float theta){
 return mat4(cos(theta), 0.0, sin(theta), 0.0, 0.0, 1.0, 0.0, 0.0, -sin(theta), 0.0, cos(theta), 0.0, 0.0, 0.0, 0.0, 1.0);
}

mat4 rotmatXaxis(float theta){
 return mat4(1.0, 0.0, 0.0, 0.0, 0.0, cos(theta), sin(theta), 0.0, 0.0, -sin(theta), cos(theta), 0.0, 0.0, 0.0, 0.0, 1.0);
}

mat4 rotmatZaxis(float theta){
 return mat4(cos(theta), sin(theta), 0.0, 0.0, -sin(theta), cos(theta), 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0);
}

mat4 matrix;
mat4 inverseMatrix;

// init transform and scale
vec3 T;
vec3 S;

vec3 iCube( in vec4 V, in vec4 W){

    T = vec3(1.0, -10.0, 10.0*sin(4.0*uTime)-10.0); // translate upward by one unit
    S = vec3(1.0, 1.0, 1.0); // scale down by one half

    //matrix = tsMatrix(T, S);
    //inverseMatrix = tsMatrix(-T/S, 1.0/S);

    //matrix = tsMatrix(vec3(0.0,0.0,0.0),1.0);
    //inverseMatrix = tsMatrix(vec3(0.0,0.0,0.0),1.0);
    inverseMatrix = rotmatXaxis(uTime) * rotmatYaxis(-uTime);

    cube[0] = vec4(-1.0,0.0,0.0,-1.0) * inverseMatrix;
    cube[1] = vec4(1.0,0.0,0.0,-1.0) * inverseMatrix;
    cube[2] = vec4(0.0,-1.0,0.0,-1.0) * inverseMatrix;
    cube[3] = vec4(0.0,1.0,0.0,-1.0) * inverseMatrix;
    cube[4] = vec4(0.0,0.0,-1.0,-1.0) * inverseMatrix;
    cube[5] = vec4(0.0,0.0,1.0,-1.0) * inverseMatrix;

//
    for(int i = 0 ; i < 6 ; i ++){

        tEnter[i] = 0.0;
        tExit[i] = 0.0;

        float LW = ( dot( cube[i], W ));
        float LV = ( dot( cube[i], V ));

        ////vec4 W = (W);

      //  if  (dot(W,cube[0])<=1.0 && dot(W,cube[1]) <= 0.0
      //    && dot(W,cube[2])<=1.0 && dot(W,cube[3]) <= 0.0
      ///    && dot(W,cube[4])<=1.0 && dot(W,cube[5]) <= 0.0
       // ){  

        //degenerate cases

        //The entire ray lies inside the half space - ignore this L
            if( abs(LW)<0.00001 && LV < -0.00001 ){
                continue;
            }

            //The entire ray lies outside the half space - missed
            if( abs(LW)<0.00001 && LV > 0.0 ){

                return vec3(1.0,1.0,1.0);

            }

            // enter the half space
            if ( LW < -0.00001 ){

                tEnter[i] = -LV/LW;

            }

            // exit the half space
            if (LW > 0.00001){

                tExit[i] = -LV/LW;

            }

       // }

       // else {
       //     return vec3(0.0,0.0,0.0);
       // }
}

    //To find the intersection of the ray with the cube, we take the maximum tenter of the entering rays, and the minimum texit of the exiting rays, and see whether tenter < texit. If so, then the ray has entered the cube at tenter. If not, then the ray has missed the cube.

    //hold the min and max values
    float maxEnter = -1e20;
    float minExit = 1e20;

    int maxIndex = 0;
    int minIndex = 0;
    float t;


    for (int i = 0 ; i < 6 ; i++){

        // entering rays

       if(tEnter[i] > maxEnter && tEnter[i] != 0.0){
            maxEnter = tEnter[i];
            maxIndex = i;
        }

        //exiting rays
        if(tExit[i] < minExit && tExit[i] != 0.0){

            minExit = tExit[i];
            minIndex = i;

        }
    }


    if( maxEnter < minExit ){

        //float j = 1.0/(maxEnter+1.0)*50.;
        return vec3(0,0,maxEnter / 100.0);

        //http://www.john-smith.me/hassles-with-array-access-in-webgl--and-a-couple-of-workarounds
        //for (int i=0; i<6; i++) {
/*
            if ( i == maxIndex ) {
                
                float j;
                
                //j = tEnter[i];//
                j = 1.0/(tEnter[i]+1.0)*50.;

                //j = tEnter[i]*0.001; //very different results

                return vec3(0.0,0.0,1.0);
                break;
            }
            */
        //}
    }


    else {

        return vec3(1.0,1.0,1.0); 

    }
}

float iSphere( in vec3 V, in vec3 W, in vec4 sph )
{
    vec3  A = V - sph.xyz; // ray origin minus sphere position - gives a vector
    float b = 2.0 * dot( A, W );
    float c = dot(A,A) - sph.w;
    float h = b*b - 4.0 *c;

    //set t to negative one to test
    if (h < 0.0) { return -1.0; }
    float t = (-b - sqrt(h)) / 2.0;
    return t;
}


float remap (in float low1, in float high1, in float low2, in float
high2, in float value){
     return low2 + (value - low1) * (high2 - low2) / (high1 - low1) ;
}


float rand(vec2 co){
    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
}


void main( void ){

    vec3 light = normalize( vec3(1.4,2.6,1.4) );    // light position
    vec2 uv = 1.0*( gl_FragCoord.xy / uViewportSize.xy );

    float focal_length = 5.0;
    vec4 V = vec4( 0.0, 0.0, 60.0, 1.0); //ray origin
    vec4 W = normalize( vec4( -0.5 + uv.x,0.5 - uv.y, -focal_length, 0.0) );

    vec3 cube = iCube(V,W);
    //float cyl = iCylinder(V,W,cyl);

  //  vec3 col = vec3(0.0);
   // vec3 col2 = vec3(0.0);

    gl_FragColor = vec4( cube, 1.0 );
}
</script>

<script>start()</script>