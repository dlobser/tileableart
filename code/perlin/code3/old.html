
<!! ASSIGNMENT DUE WEDNESDAY SEPTEMBER 18, 2013 FOR KEN PERLIN'S GRAPHICS CLASS>

<script src="script.js"></script>

<!! REPLACE THE TEXT BELOW WITH A TITLE FOR YOUR SHADER>

<script id="title" type="text/plain">
Old VHS meets film strip
</script>

<!! REPLACE THE TEXT BELOW WITH A BRIEF DESCRIPTION OF YOUR SHADER>

<script id="description" type="text/plain">
Your homework this week is to write a more interesting shader than the one below.

A fragment shader can use time plus position as input, and produce color as output.

NOTE 1: Allowable data types: float, vec2, vec3 and vec4.
NOTE 2: Constants must have decimal points. Example: "4.0", not "4".

</script>

<!! REPLACE THE TEXT BELOW WITH YOUR SHADER CODE>


<script id="shader" type="x-shader/x-fragment">

  

  float time = uTime;


  //test blinking
  float onoff (float num)
  {
    if(num>0.0) return 1.0;
    else return 0.0;
  }


  vec3 nSphere( in vec3 pos, in vec4 sph )
  {
    return ( pos - sph.xyz ) / sph.w;
  }



vec4 sph1 = vec4(0.0, sin(time*20.0)*0.1, 0.0, 1.0); // sphere. w --> rayon

// intersections

/*
float iPlane(in vec3 ro, in vec3 rd )
{
  return -ro.y / rd.y;
}
*/

float iSphere( in vec3 ro, in vec3 rd, in vec4 sph )
{
    vec3 oc = ro - sph.xyz; // On place la sphere Ã  l'origine de la camÃ©ra
    float b = 2.0 * dot( oc, rd );
    float c = dot(oc, oc) - sph.w * sph.w; // w should be size
    float h = b*b - 4.0 *c;
    if (h<0.0) { return -1.0; }
    float t = (-b - sqrt(h)) / 2.0;
    return t;
}

// should be int for comparisons
float intersect( in vec3 ro, in vec3 rd, out float resT ) 
{
      resT = 1000.;
      float id = -1.0;
      float tmin = -1.0;
      float tsph = iSphere( ro, rd, sph1 );
     // float tpla = iPlane( ro, rd );

      if ( tsph > 0.0 ) {
          resT = tsph;
          id = 1.0;
      }

      return id;
}
 

    void main(void) 
    {

    /*
    float t = onoff(sin(time*20.0));
    vec3 color = vec3(t);
    gl_FragColor = vec4(color, 1.0);*/

    //what is uViewPortSize?
    vec2 resolution = uViewportSize;

    vec3 light = normalize( vec3(0.5,1.0,0.4) );  // light position

     //this is weird - fviewportsize doesn't seem to do anything
    vec2 uv = ( gl_FragCoord.xy / resolution.xy );  // gl_FragCoord
    // old  vec2 uv = ( gl_FragCoord.xy / resolution.xy );  // gl_FragCoord



    sph1.xz = vec2 (0.0,  0); // Coord sphere

    vec3 ro = vec3( .0, 0.0, 2.0 ); //Origine rayon

    vec3 rd = normalize( vec3( -1.0 + 2.* uv *
    vec2(resolution.x/resolution.y, 1.0), -1.0 ) ); // Dir rayon

    float t;

    float id = intersect( ro, rd, t ); 

    vec3 col = vec3(0.65);

    //this is silly - the result of returning a float for id
    if ( id > 0.5 && id < 1.5 ) // sphere
    {
       vec3 pos = ro + t * rd;
       vec3 nor = nSphere( pos, sph1 );
       float dif = clamp( dot( nor, light ), 0.0, 1.0); // lumiere diffuse
       float ao = 1.;//0.5 + 0.5 * nor.y;
       col = vec3( 0.8, 0.8, 0.6) * dif * ao + vec3(0.1, 0.2, 0.4) * ao;
    }

    gl_FragColor = vec4( col, 1.0 ); // Couleur final du pixel

    }



</script>

<script>start()</script>
