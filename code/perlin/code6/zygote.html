
<head><script src=gl.js></script><script src=build.js></script></head>
<body style="background:black" onload=glStart();>
<center>
  <!--
<table width=90%><tr><td>
<hr color=white size=20>

<tr>
<td>
<center><canvas id=canvas1 data-render=gl width=400 height=400
tabindex="1"></canvas></center>

<td>&nbsp;</td>
<td>
<center><canvas id=canvas2 data-render=gl width=400 height=400
tabindex="1"></canvas></center>
</td>
</tr>
</table>
</center>
<hr>
-->
<div style="cursor:crosshair">
<h2 style="font-family:sans-serif;color:white">Zygote</h2>
<p style="font-family:sans-serif;color:white;font-size:1em">use the mouse to control the motion</p>
<canvas id=canvas1 data-render=gl width=600 height=600
tabindex="1"></canvas>
</div>


<script id=fs_phong type=x-shader/x-fragment>
    uniform float p[10];
    uniform vec3 lDir;
    varying vec3 vNormal;
    varying vec2 vUV;

      vec4 mod289(vec4 x)
  {
    return x - floor(x * (1.0 / 289.0)) * 289.0;
  }

  vec4 permute(vec4 x)
  {
    return mod289(((x*34.0)+1.0)*x);
  }

  vec4 taylorInvSqrt(vec4 r)
  {
    return 1.79284291400159 - 0.85373472095314 * r;
  }

  vec2 fade(vec2 t) {
    return t*t*t*(t*(t*6.0-15.0)+10.0);
  }

  // Classic Perlin noise // *cough
  float cnoise(vec2 P)
  {
    vec4 Pi = floor(P.xyxy) + vec4(0.0, 0.0, 1.0, 1.0);
    vec4 Pf = fract(P.xyxy) - vec4(0.0, 0.0, 1.0, 1.0);
    Pi = mod289(Pi); // To avoid truncation effects in permutation
    vec4 ix = Pi.xzxz;
    vec4 iy = Pi.yyww;
    vec4 fx = Pf.xzxz;
    vec4 fy = Pf.yyww;

    vec4 i = permute(permute(ix) + iy);

    vec4 gx = fract(i * (1.0 / 41.0)) * 2.0 - 1.0 ;
    vec4 gy = abs(gx) - 0.5 ;
    vec4 tx = floor(gx + 0.5);
    gx = gx - tx;

    vec2 g00 = vec2(gx.x,gy.x);
    vec2 g10 = vec2(gx.y,gy.y);
    vec2 g01 = vec2(gx.z,gy.z);
    vec2 g11 = vec2(gx.w,gy.w);

    vec4 norm = taylorInvSqrt(vec4(dot(g00, g00), dot(g01, g01), dot(g10, g10), dot(g11, g11)));
    g00 *= norm.x;  
    g01 *= norm.y;  
    g10 *= norm.z;  
    g11 *= norm.w;  

    float n00 = dot(g00, vec2(fx.x, fy.x));
    float n10 = dot(g10, vec2(fx.y, fy.y));
    float n01 = dot(g01, vec2(fx.z, fy.z));
    float n11 = dot(g11, vec2(fx.w, fy.w));

    vec2 fade_xy = fade(Pf.xy);
    vec2 n_x = mix(vec2(n00, n01), vec2(n10, n11), fade_xy.x);
    float n_xy = mix(n_x.x, n_x.y, fade_xy.y);
    return 2.3 * n_xy;
  }


    void main(void) {

       // NORMALIZE LENGTH OF THE INTERPOLATED NORMAL

       vec2 noise = vec2(sin(vUV.x*sin(vUV.x*33.)*4.5),sin(vUV.y*sin(vUV.y*33.)*4.5));

       vec3 normal = normalize(vNormal)*((cnoise(vUV*20.)*.1)+.9);

       // COMPUTE DIFFUSE FACTOR

       

       float ldn = dot(lDir, normal);
       float diffuse = (-normal.z+1.)+max(0., ldn);//*noise.y;

       // COMPUTE SPECULAR FACTOR

       vec3 refl = 2. * ldn * normal - lDir;
       float specular = pow(max(0., refl.z)*((-normal.z+1.)*3.)*(max(0.,-cnoise(vUV*20.)+1.)*1.), p[9]);

       // SUM PHONG REFLECTION COMPONENTS

       vec3 c = vec3(p[0],p[1],p[2]) * (-vNormal.y + 1.) +
                vec3(p[3],p[4],p[5]) * diffuse +
                vec3(p[6],p[7],p[8]) * specular;

       // APPLY GAMMA CORRECTION

       gl_FragColor = vec4(pow(c.x,1.),pow(c.y,0.45),pow(c.z,0.45),1.);
    }
</script>

<script id=fs_uv type=x-shader/x-fragment>
    uniform vec3 rgb;
    varying vec3 vNormal;
    varying vec2 vUV;
    void main(void) {
       float c = 2.*max(0.,dot(vec3(.3,.3,.3),normalize(vNormal)));
       float u = .5+.5*sin(30.*vUV.x);
       float v = .5+.5*sin(40.*vUV.y);
       gl_FragColor = vec4(c*rgb*vec3(u,v,1.), 1.);
    }
</script>

<script>


    canvas1.setup = function() {
      
     
      this.tents = [];

      this.addTent(20,'sphere');
      this.addTent(20,'sphere');
      this.addTent(20,'sphere');
      this.addTent(20,'sphere');
      this.addTent(10,'sphere');

      this.tents[4][4].add(this.tents[0][0]);
      this.tents[4][4].add(this.tents[1][0]);
      this.tents[4][0].add(this.tents[2][0]);
      this.tents[4][0].add(this.tents[3][0]);

      //this.addObject(createParametric(1/24,1/12,sph), 'fs_phong');

      console.log(this.tents);



    }

    canvas1.addTent = function(num,typer){
      var that = this;
      var type = typer || 'cube';

      //var num = num;
      var tent = [];
     
      for(var i = 0 ; i < num ; i++){
       
        if(type=='cube')
        that.addObject(createCube(), 'fs_phong');
        else
        this.addObject(createParametric(1/24,1/12,sph), 'fs_phong');
        tent.push(that.objects[that.objects.length-1]);
        
        if(i>0){
          tent[i-1].add(tent[i]);
        }
      }

      that.tents.push(tent);

    }
        
    canvas1.update = function() {
      

        
        for(var i = 0 ; i < this.tents.length ; i++){
          var color = 0;
          for(var j = 0 ; j < this.tents[i].length ; j++){

            var obj = this.tents[i][j];
            var off = 0;
            if(i>1)
              off=.7;

            var parms = [];

            var m = ((this.mouseX*0.01)+1)||1;
           
            //parms.x = Math.sin(time*5)*.05;
            parms.y = .1;
            parms.rz = Math.sin((m*-time+off+(j/10))*2)*.04*j*((this.mouseY*0.002)+0.1);
            parms.rx = Math.sin((m*-time+off+(j/5))*1)*.007*j;
            parms.sx = parms.sy = parms.sz = .92;

            //arms
            if(i==0 && j==0){
              parms.y = 0;
              parms.rz = (Math.sin((m*-time+off)*2)*.3)-1;
              parms.rx = 0;
              parms.z = -0.1;
            }
            if(i==1 && j==0){
              parms.y = 0;
              parms.rz = (Math.sin((m*-time+off)*2)*.3)+Math.PI-1;
              parms.rx = Math.PI;
              parms.z = -0.1;

            }
            //legs
            if(i==2 && j==0){
              parms.y = -.02;
              parms.x = -.05;
              parms.z = -.1;
              parms.rz = (Math.sin((m*-time+off)*2)*.7)-2;
              parms.rx = 0;
              parms.sx = parms.sy = parms.sz = .85;
            }
            if(i==3 && j==0){
              parms.y = -.02;
              parms.x = .05;
              parms.z = -.1;
              parms.rz = (Math.sin((m*-time+off)*2)*.7)+Math.PI-2;
              parms.rx = Math.PI;
              parms.sx = parms.sy = parms.sz = .85;
            }
            //head
            if(i==4){
              if(j==0){
                parms.sx = parms.sy = parms.sz = 1.15;
                parms.y = Math.sin((m*-time+off)*2)*.1;
                parms.rz = Math.sin(m*-time+off*1)*-.5;
              }
              else if(j==9){
                 parms.sx = parms.sy = parms.sz = 2;
              }
              else{
                 parms.sx = parms.sy = parms.sz = .92;
                parms.y = .05+(Math.sin((m*-time-off+(j/10))*2)*0.01);
                parms.rz = Math.sin((m*-time+off+(j/10))*1)*.01*j;
              }
              
              parms.rx = Math.sin((m*-time+off+(j/5))*1)*.01*j;
             
            }

            var scaleMat = makeMatrix(parms);

            obj.pMatrix = scaleMat;

            obj.matrix = recurse(obj,obj.pMatrix);

            color+=(1/this.tents[i].length);
            obj.setUniform('p', [color,0,0, color,color,0, 1,.5,.3,3]);
            if(i==4&&j==9) //make the head red
               obj.setUniform('p', [.2,.02,0, 1,0,0, 1,.3,0,3]);

            obj.setUniform('lDir', [.57,.57,0.]);

            
          }
        }
        if (this.mousePressed)
           console.log("canvas1 drag " + this.mouseX + " " + this.mouseY);
    }


    var sph = function(u,v) {
       var theta = 2 * Math.PI * u,
           phi = Math.PI * (v - .5),
           cosT = Math.cos(theta) *.1, cosP = Math.cos(phi)*1 ,
           sinT = Math.sin(theta) *.1, sinP = Math.sin(phi)*.1 ;
       return [ cosT * cosP, sinT * cosP, sinP ];
    }

</script>
</center>
</body>

